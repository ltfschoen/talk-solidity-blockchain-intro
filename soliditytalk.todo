Slide deck:
 ☐ cite quotes
 ☐ contrib link @ start
 ☐ setup script for cloning libraries: get-example-libs.sh
☐ go through todos, work out images & demo code needed:
  #p35
images:
  ☐ <!--pic01--> chain / EVM / solidity system diagram
  ☐ <!--pic02--> same again, but with LLL & Serpent added for good measure
    ☐ bring this back in relevant discussion about access levels
  ☐ <!--picRT--> storage/ref types onchain/inEVM location pic
    ☐ include where context coercion happens
  ☐ <!--picIO--> software layers in a web app vs blockchain (large system complexity buffering)
  ☐ <!--picABI--> ABI/Solidity contract interfaces diagram
  ☐ work out convention colours for imagery. WHAT NEEDS DRAWING?!
verify stuff:
  ☐ is contract storage & bytecode same block of memory or can storage vary?
  ☐ write test code to explain behaviour of function `storage` vars (persist after transaction?)
  ☐ Is storage referenced by inner vars modified by mutations stemming from calls to external contract functions?
  ☐ check that fallback funcs are always public
  ☐ check bit math for manipulating byte arrays and add that if can be bothered
demo code:
  required:
    ☐ address typecasting
  optional:
    ☐ passing a string over the ABI
    ☐ audit function libraries and pull / link useful ones
      - ABI encoders / decoders
      - ADTs along the lines of the C STL
    ☐ saving some data using web stack vs ethereum
filler:
  ☐ words of warning
  ☐ "Best places to get started"
  ✔ "Blockchain not always best answer" @done (16-07-04 20:58)
  ✔ types intro @done (16-07-04 20:58)
  ☐ Contracts calling contracts (scary time)


Research:
 ☐ go through Eris tutorial info
 ☐ unanswered questions:
   ☐ make some inter-contract method calls and see what the caveats are
   ☐ deploy another DAO on the testnet, wipe it from Mix, attempt to make a contract that creates new instances of it
   - Test if/how fixed point rounding works
 - Design patterns
   - http://solidity.readthedocs.io/en/latest/common-patterns.html
 - Unit testing:
   [Find a framework that outputs useful benchmarking data]
   ☐ get dapple setup and see how unit testing operates
   - gas cost (indicator of computational complexity / electrical cost; estimated and actual)
   - memory & storage usage (indicator of long-term storage efficiency)
   - See if sol-unit / sunit is runnable and try to plug something in to it
 - Benchmark various techniques to work out what's best
   At what rate does gas cost increase? In proportion to what?
   ☐ gas costs for storage manipulation: multiple mods vs single mod vs memory copy mod & replace
   ☐ gas costs for internal, external & library function calls
   ☐ gas costs for internal & external self / parent / ancestor / multiparent lookups
   ☐ storage size of dynamic arrays with different int sizes for elements (is each slot padded to 256 bits?)
   - Understand inheritance: concatenative or delegative?
   - see what happens when you try to run a function on a user account address

 ☐ Is it possible, or will it be possible, to bind Solidity types and contract source code to bytecode for debugging purposes, for external contracts someday? or now? can i hack mix?
 ☐ investigate generation of call-flow graphs

 - Interfacing with IPFS?

Useful services:
  - Ethereum alarm clock
  - RANDAO https://github.com/randao/randao
